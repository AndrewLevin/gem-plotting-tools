#!/bin/env python

r"""
``plotLatComp.py`` - compares sbit threshold measurements
================================================================

Synopsis
--------

**plotLatComp.py** [*OPTIONS*]

Description
-----------

This script reads in a list of scandate file, see :func:`gempython.gemplotting.utils.anautilities.parseListOfScanDatesFile` for details, and for each scandate the set of N_Hits vs. CFG_LATENCY plots (generated by :program:`gempython.vfatqc.ultraLatency.py`) for each VFAT position will be plotted on a common 3x8 grid canvas.  A TLegend will automatically be plotted and the legend entry will be taken from the third column of the input list of scandates files.

Arguments
---------

Mandatory arguments
...................

The following list shows the mandatory inputs that must be supplied to execute
the script:

.. program:: plotLatComp.py

.. option:: filename <FILE>

    Physical filename of the input file to be passed to :program:`plotLatComp.py`.
    The format of this input file should follow the :doc:`Three Column Format
    </scandate-list-formats>`.

Optional arguments
..................

The following list shows the optional inputs that can be supplied when
executing the script:

.. option:: -a,--alphaLabels

    Provide this argument if alphanumeric characters exist in the third column of :option:`filename`.

.. option:: -e,--eventsPerLat

    Will set the height of the y-axis on all output plots to the value provided here; this should represent the number of events per latency bin.

.. option:: -n,--noLeg

    If provided, do not draw a TLegend on the output plots

.. option:: -s --savePlots

   Make *.png file for all plots that will be saved in the output TFile 

Example
-------

.. code-block:: bash

    plotLatComp.py -a -e 100 inputListOfScanDates.txt 

"""

def compareLatResults(args):
    # Suppress all pop-ups from ROOT
    import ROOT as r
    r.gROOT.SetBatch(True)
    
    # Check Paths
    import os, sys
    from gempython.utils.wrappers import envCheck
    envCheck('DATA_PATH')
    envCheck('ELOG_PATH')
    elogPath = os.getenv('ELOG_PATH')

    # Get info from input file
    from gempython.gemplotting.utils.anautilities import getCyclicColor, getDirByAnaType, filePathExists, make3x8Canvas, parseListOfScanDatesFile
    parsedTuple = parseListOfScanDatesFile(args.filename,alphaLabels=args.alphaLabels)
    listChamberAndScanDate = parsedTuple[0]
    chamberName = listChamberAndScanDate[0][0]

    legPlot = r.TLegend(0.5,0.5,0.9,0.9)

    from gempython.utils.nesteddict import nesteddict as ndict
    dict_Histos = ndict()
    dict_Graphs = ndict()
    dict_MultiGraphs = {}
    
    print("Loading data from input list of scandates file")
    from gempython.gemplotting.utils.anaInfo import tree_names
    for idx,infoTuple in enumerate(listChamberAndScanDate):
        # Setup the path
        dirPath = getDirByAnaType("latency", infoTuple[0])
        if not filePathExists(dirPath, infoTuple[1]):
            print('Filepath {:s}/{:s} does not exist!'.format(dirPath, infoTuple[1]))
            print('Please cross-check, exiting!')
            sys.exit(os.EX_NOINPUT)
        filename = "{:s}/{:s}/{:s}".format(dirPath, infoTuple[1], tree_names["latencyAna"][0])
        if not os.path.isfile(filename):
            print('File {:s} does not exist!'.format(filename))
            print('Please cross-check, exiting!')
            sys.exit(os.EX_NOINPUT)

        # Load the file
        r.TH1.AddDirectory(False)
        scanFile   = r.TFile(filename,"READ")
        
        if scanFile.IsZombie():
            print("{:s} is a zombie!!!".format(filename))
            print("Please double check your input list of scandates: {:s}".format(args.filename))
            print("And then call this script again")
            raise IOError

        ###################
        # Get individual distributions
        ###################
        for vfat in range(24):
            baseDir = "VFAT_Plots/VFAT{0:d}".format(vfat)
            dict_Histos[infoTuple[2]][vfat] = scanFile.Get("{:s}/vfat{:d}HitsVsLat".format(baseDir,vfat))
            dict_Graphs[infoTuple[2]][vfat] = scanFile.Get("{:s}/g_N_vs_Lat_VFAT{:d}".format(baseDir,vfat))
            
            # Make the TMultiGraph Objects
            suffix = "VFAT{:d}".format(vfat)
            if idx == 0:
                dict_MultiGraphs[vfat] = r.TMultiGraph("mGraph_RateVsThrDac_vfat{:s}".format(suffix),suffix)

            # Set Style of TGraph
            dict_Graphs[infoTuple[2]][vfat].SetLineColor(getCyclicColor(idx))
            dict_Graphs[infoTuple[2]][vfat].SetMarkerColor(getCyclicColor(idx))
            dict_Graphs[infoTuple[2]][vfat].SetMarkerStyle(20+idx)
            dict_Graphs[infoTuple[2]][vfat].SetMarkerSize(0.8)

            # Add to the MultiGraph
            dict_MultiGraphs[vfat].Add(dict_Graphs[infoTuple[2]][vfat])

            ###################
            # Make an entry in the TLegend
            ###################
            if vfat == 0:
                print("infoTuple[2] = ", infoTuple[2])
                legPlot.AddEntry(
                        dict_Graphs[infoTuple[2]][vfat],
                        "{0}".format(infoTuple[2]),
                        "LPE")
                pass
            pass
    
    ###################
    # Make output ROOT file
    ###################
    outFileName = "{0}/compLatResults_{1}.root".format(elogPath,chamberName)
    outFile = r.TFile(outFileName,"RECREATE")

    ###################
    # Now Make plots
    ###################
    print("Making output plots")
    dict_canv = {}
    for vfat in range(24):
        # Make Output Canvas
        dict_canv[vfat] = r.TCanvas("canvLatResults_VFAT{0}".format(vfat),"Hits vs. CFG_LATENCY Value",700,700)
        dict_canv[vfat].cd()
        dict_MultiGraphs[vfat].Draw("APE1")
        dict_MultiGraphs[vfat].GetYaxis().SetTitle("Hits #left(A.U.#right)")
        dict_MultiGraphs[vfat].GetYaxis().SetRangeUser(0,args.eventsPerLat) # max is 40 MHz
        dict_MultiGraphs[vfat].GetXaxis().SetTitle("CFG_LATENCY #left(BX#right)")
        dict_MultiGraphs[vfat].Draw("APE1")

        # Draw Legend?
        if not args.noLeg:
            legPlot.Draw("same")
            pass

        # Make output image?
        if args.savePlots:
            dict_canv[vfat].SaveAs("{0}/{1}.png".format(elogPath,dict_canv[vfat].GetName()))
            pass

        # Store Output
        thisDirectory = outFile.mkdir("VFAT{0}".format(vfat))
        thisDirectory.cd()
        dict_MultiGraphs[vfat].Write()
        dict_canv[vfat].Write()
        pass

    # Make summary canvases, always save these
    canvLatResults_Summary = make3x8Canvas("canvLatResults_Summary",dict_MultiGraphs.values()[0:24],"APE1")
                
    # Draw Legend?
    if not args.noLeg:
        canvLatResults_Summary.cd(1)
        legPlot.Draw("same")
        pass

    # Save summary canvases (always)
    print("\nSaving Summary TCanvas Objects")
    #canvLatResults_Summary.SaveAs("{0}/{1}.png".format(elogPath,canvLatResults_Summary.GetName()))

    # Close output files
    outFile.Close()
    
    print("You can find all ROOT objects in:")
    print("\n\t{0}//compLatResults_{1}.root\n".format(elogPath,chamberName))

    print("You can find all plots in:")
    print("\n\t{0}\n".format(elogPath))

    print("Done")

    return

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description="Arguments to supply to plotLatComp.py")

    parser.add_argument("filename", type=str, help="Tab delimited filename specifying list of scandates to compare. First line understood as column header.  First column is chamber_name, second is scandate, and third will be used to fill a TLegend.  See documentation for parseListOfScanDatesFile(...) for more details")
    parser.add_argument("-a","--alphaLabels", action="store_true",help="Provide this argument if alphanumeric characters exist in the third column of the input file")
    parser.add_argument("-e","--eventsPerLat",type=int,help="Number of events per latency bin; used to set height of y-axis on all output plots",default=100)
    parser.add_argument("-n","--noLeg", action="store_true",
            help="Do not draw a TLegend on the output plots")
    parser.add_argument("-s","--savePlots", action="store_true",
            help="Make *.png file for all plots that will be saved in the output TFile")
    parser.set_defaults(func=compareLatResults)
    args = parser.parse_args()
    args.func(args)

    print("Goodbye")
